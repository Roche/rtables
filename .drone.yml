
# This file was automatically merged from several files at time Thu May  9 11:38:51 DST 2019

# On Push to master: build R package, push R package doc to file server, deploy/release in Docker
# for master: also push to R repo and create a github release (which automatically tags it)

# we camelcase environment variables in R (got via Sys.getenv) to distinguish them from the other variables

kind: pipeline
name: deploy on push to master and devel

trigger:
  branch:
  - master
  - devel
  event:
  - push

image_pull_secrets:
- .dockerconfigjson

clone:
  disable: true

volumes:
# need to set repository as trusted in drone.io
- name: sshkeys
  host:
    path: /home/ubuntu/sshkeys # this is wrt host drone is running on (because docker daemon is shared!!)

steps:
- name: Info about run
  image: alpine
  commands:
  - printenv

- name: create_dirs
  image: alpine
  commands:
  - mkdir shared_vars # used to share variables between steps
  - mkdir docker_dir # for the docker files

- name: clonerepo
  # we don't take the standard drone/git behavior because it only has five parameters and we need a more customized git setup
  image: plugins/git
  commands:
  - git clone "${DRONE_GIT_HTTP_URL}" sourcecode
  - cd sourcecode
  - git branch -a
  - git checkout "$DRONE_COMMIT_SHA"
  - git status

- name: Directory contents
  image: alpine
  commands:
  - pwd
  - ls . sourcecode

# build the R package and move tar.gz to the right directories, also write the docker image name to be read by successive steps
- name: build the R package
  image: docker.bioclinr.com:10021/nest/allprojects_${DRONE_BRANCH}:newest_version
  pull: always
  entrypoint:
  - bash
  commands:
  - |-
    R --vanilla <<- 'EOF'

    library(automation.utils)

    pkg_dir <- "sourcecode"
    build_pkg(pkg_dir = pkg_dir)

    EOF
  - ls shared_vars


# push to the R repository before building docker image (because it loads what has been uploaded there)
- name: push to rrepo
  image: docker.bioclinr.com:10021/nest/allprojects_${DRONE_BRANCH}:newest_version
  pull: always
  entrypoint:
  - bash
  environment:
    R_RELEASE_REGISTRY_URL: "http://rran.bioclinr.com:8081/repository/NEST-R/"
    R_DEV_REGISTRY_URL: "http://rran.bioclinr.com:8081/repository/NEST-R-dev/"
    R_REGISTRY_USER: NESTPushuser
    R_REGISTRY_PASSWORD:
      from_secret: NEXUS_REGISTRY_PASSWORD
  commands:
  - |-
    R --vanilla <<- 'EOF'
    library(automation.utils)

    rReleaseRegistryURL <- utils.nest::sys_env_non_empty("R_RELEASE_REGISTRY_URL")
    rDevRegistryURL <- utils.nest::sys_env_non_empty("R_DEV_REGISTRY_URL")
    registryUser <- utils.nest::sys_env_non_empty("R_REGISTRY_USER")
    registryPassword <- utils.nest::sys_env_non_empty("R_REGISTRY_PASSWORD")
    branch_name <- utils.nest::sys_env_non_empty("DRONE_BRANCH")

    pkg_dir <- "sourcecode"
    registry_url <- switch(
      branch_name,
      master = rReleaseRegistryURL,
      devel = rDevRegistryURL,
      stop(utils.nest::glue_with_null("No registry for branch {branch_name}"))
    )
    push_to_rregistry(registryUser, registryPassword, registry_url, pkg_dir, build = FALSE)
    EOF

- name: trigger docker build (does not wait)
  image: plugins/downstream
  settings:
    server: http://${DRONE_SYSTEM_HOSTNAME}
    token:
      from_secret: DRONE_SERVER_TOKEN
    fork: true # trigger new build number
    repositories:
    - NEST/docker_images
    params:
    - PARAM_UPSTREAM_INFO=${DRONE_REPO}_${DRONE_BUILD_NUMBER}
    - PARAM_DOCKER_IMAGE_MODE=${DRONE_BRANCH}
    wait: true
    timeout: 10 #time to wait to start build if another build is running, otherwise fails

- name: build pkgdown documentation and push to github
  image: docker.bioclinr.com:10021/nest/allprojects_${DRONE_BRANCH}:newest_version
  pull: always
  environment:
    FILESERVER_GITHUB_OWNER: "NEST" #todo: change
    FILESERVER_GITHUB_REPO_NAME: "docs" #todo: change
    FILESERVER_GITHUB_API_SERVER: "https://github.roche.com/api/v3"
    FILESERVER_GITHUB_TOKEN:
      from_secret: githubFileserverToken
    FILESERVER_GIT_BRANCH: "master"

    GITHUB_REPO_TOKEN:
      from_secret: githubRepoToken
    GITHUB_API_SERVER: "https://github.roche.com/api/v3"
  volumes:
  - name: sshkeys
    path: /root/.ssh
  entrypoint:
  - bash #to avoid starting RStudio
  commands:
  - |-
    R --vanilla <<- 'EOF'
    library(automation.utils)

    full_repo_name <- utils.nest::sys_env_non_empty("DRONE_REPO")
    branch_name <- utils.nest::sys_env_non_empty("DRONE_BRANCH")

    push_branch_name <- utils.nest::sys_env_non_empty("FILESERVER_GIT_BRANCH")
    fileserver_repo_metadata <- github.tools::create_repo_metadata(
      owner = utils.nest::sys_env_non_empty("FILESERVER_GITHUB_OWNER"),
      repo = utils.nest::sys_env_non_empty("FILESERVER_GITHUB_REPO_NAME"),
      github_api_server = utils.nest::sys_env_non_empty("FILESERVER_GITHUB_API_SERVER"),
      github_token = utils.nest::sys_env_non_empty("FILESERVER_GITHUB_TOKEN"),
      check_repo_exists = TRUE
    )

    pkg_dir <- "sourcecode"
    build_pkgdown_website(pkg_dir, branch = branch_name)

    upload_type <- drone_get_upload_type()
    target_dir <- copy_rdoc_to_remote_git(
      pkg_dir = pkg_dir,
      full_repo_name = full_repo_name,
      upload_type = upload_type,
      repo_metadata = fileserver_repo_metadata,
      branch = push_branch_name
    )
    doc_url <- get_ghpages_url(repo_metadata = fileserver_repo_metadata, subpath = target_dir)
    print(utils.nest::glue_with_null("Uploaded documentation to '{doc_url}'"))

    if (upload_type == "temp") {
      repo_metadata <- github.tools::create_repo_metadata(
        owner = utils.nest::sys_env_non_empty("DRONE_REPO_NAMESPACE"),
        repo = utils.nest::sys_env_non_empty("DRONE_REPO_NAME"),
        github_api_server = utils.nest::sys_env_non_empty("GITHUB_API_SERVER"),
        github_token = utils.nest::sys_env_non_empty("GITHUB_REPO_TOKEN"),
        check_repo_exists = TRUE
      )
      pr_id <- as.integer(utils.nest::sys_env_non_empty("DRONE_PULL_REQUEST"))
      commit_sha <- utils.nest::sys_env_non_empty("DRONE_COMMIT_SHA")
      update_pr_temp_doc_description(doc_url, pr_id, commit_sha, repo_metadata = repo_metadata)
    }

    EOF

- name: check docker build succeeded
  image: python:3
  environment:
    PLUGIN_UPSTREAM_INFO: "${DRONE_REPO}_${DRONE_BUILD_NUMBER}"
    PLUGIN_DRONE_SERVER: "http://${DRONE_SYSTEM_HOSTNAME}"
    PLUGIN_REPO_NAME: NEST/docker_images
    PLUGIN_MAX_NB_TRIALS: -1
    PLUGIN_TIMEOUT: 10
  entrypoint:
  - bash
  commands:
  - cd /tmp
  - wget https://raw.github.roche.com/mordigm/automationTest/master/droneio/docker_containers/check_downstream/wait_for_downstream.py
  - python wait_for_downstream.py
  - rm wait_for_downstream.py
# export PLUGIN_UPSTREAM_INFO=mordigm/nesttest-testRpkg2_103
# export PLUGIN_DRONE_SERVER=http://ci2.bioclinr.com
# wget https://raw.github.roche.com/mordigm/automationTest/master/droneio/docker_containers/wait_for_downstream/wait_for_downstream.py
# python wait_for_downstream.py

---

# check pull-requests (on all kinds of branches)
# we first merge the target branch into the PR branch

# master: we do not enforce that the package version has increased because some hotfixes may make it necessary to update the same package version
# Old: we can check that the version has increased (and not skipped), that the changelog was updated

kind: pipeline
name: check PR

trigger:
  branch:
  - master
  - devel
  event:
  - pull_request

image_pull_secrets:
- .dockerconfigjson

clone:
  disable: true

volumes:
# need to set repository as trusted in drone.io
- name: sshkeys
  host:
    path: /home/ubuntu/sshkeys # this is wrt host drone is running on (because docker daemon is shared!!)

steps:
- name: Check branch condition (pre-release)
  image: python:3
  entrypoint:
  - bash
  commands:
  - |
    cat <<- EOF > test.py
    if (('${DRONE_TARGET_BRANCH}' == 'master') and (not '${DRONE_SOURCE_BRANCH}'.startswith('pre-release'))): print("Only pre-release can merge into master"); quit(1)
    EOF
  - python test.py

- name: Info about run
  image: alpine
  commands:
  - printenv

- name: clonerepo
  # we don't take the standard drone/git behavior because it only has five parameters and we need a more customized git setup
  image: plugins/git
  commands:
  # github only enforces merged commits upon merging, before (e.g. when PR is still open, they can potentially not be merged)
  # rather than merging the PR into master, we merge master into PR to keep master clean locally because we check against the Rpackage version of master
  - git config --global user.email "drone@user.com"
  - git config --global user.name "Drone CI / CD" # needed because of merge
  - git clone "$DRONE_GIT_HTTP_URL" sourcecode # we pull everything because we also need the master, shallow clone does not work because it only clones the current HEAD and not all branches
  - cd sourcecode
  - git branch -a
  - git checkout origin/"$DRONE_TARGET_BRANCH"
  # see https://stackoverflow.com/questions/51342289/proper-way-to-programmatically-check-if-git-branches-can-be-merged
  - GIT_EDITOR=true git merge "$DRONE_COMMIT_SHA" #without origin, may give an error
  - git status
  #todo: add again
  #- '[ "$(git diff --name-only origin/"$DRONE_TARGET_BRANCH" -- .drone.yml)" == "" ] || exit 1' # fail if yaml is different from target branch


- name: check code
  image: docker.bioclinr.com:10021/nest/allprojects_${DRONE_BRANCH}:newest_version
  pull: always
  environment:
    GITHUB_REPO_TOKEN:
      from_secret: githubRepoToken
    GITHUB_API_SERVER: "https://github.roche.com/api/v3"
  entrypoint:
  - bash
  commands:
  - |-
    R --vanilla <<- 'EOF'
    library(automation.utils)

    branch_name <- utils.nest::sys_env_non_empty("DRONE_BRANCH")

    pkg_dir <- "sourcecode"

    if (identical(branch_name, "master")) {
      #todo: add again
      # utils.nest::stop_if_not(list(version_correct_for_deploy(pkg_dir, drone_get_repo_metadata()), "The version is not correct for the deploy"))
      # utils.nest::stop_if_not(list(changelog_updated(pkg_dir), "The changelog does not contain the version of the release."))
    }
    #todo: remove installed package of same name??
    utils.nest::stop_if_not(list(utils.nest::check_pkg(pkg_dir)$passed, "The package does not pass the checks."))
    EOF

- name: build pkgdown documentation and push to github
  image: docker.bioclinr.com:10021/nest/allprojects_${DRONE_BRANCH}:newest_version
  pull: always
  environment:
    FILESERVER_GITHUB_OWNER: "NEST" #todo: change
    FILESERVER_GITHUB_REPO_NAME: "docs" #todo: change
    FILESERVER_GITHUB_API_SERVER: "https://github.roche.com/api/v3"
    FILESERVER_GITHUB_TOKEN:
      from_secret: githubFileserverToken
    FILESERVER_GIT_BRANCH: "master"

    GITHUB_REPO_TOKEN:
      from_secret: githubRepoToken
    GITHUB_API_SERVER: "https://github.roche.com/api/v3"
  volumes:
  - name: sshkeys
    path: /root/.ssh
  entrypoint:
  - bash #to avoid starting RStudio
  commands:
  - |-
    R --vanilla <<- 'EOF'
    library(automation.utils)

    full_repo_name <- utils.nest::sys_env_non_empty("DRONE_REPO")
    branch_name <- utils.nest::sys_env_non_empty("DRONE_BRANCH")

    push_branch_name <- utils.nest::sys_env_non_empty("FILESERVER_GIT_BRANCH")
    fileserver_repo_metadata <- github.tools::create_repo_metadata(
      owner = utils.nest::sys_env_non_empty("FILESERVER_GITHUB_OWNER"),
      repo = utils.nest::sys_env_non_empty("FILESERVER_GITHUB_REPO_NAME"),
      github_api_server = utils.nest::sys_env_non_empty("FILESERVER_GITHUB_API_SERVER"),
      github_token = utils.nest::sys_env_non_empty("FILESERVER_GITHUB_TOKEN"),
      check_repo_exists = TRUE
    )

    pkg_dir <- "sourcecode"
    build_pkgdown_website(pkg_dir, branch = branch_name)

    upload_type <- drone_get_upload_type()
    target_dir <- copy_rdoc_to_remote_git(
      pkg_dir = pkg_dir,
      full_repo_name = full_repo_name,
      upload_type = upload_type,
      repo_metadata = fileserver_repo_metadata,
      branch = push_branch_name
    )
    doc_url <- get_ghpages_url(repo_metadata = fileserver_repo_metadata, subpath = target_dir)
    print(utils.nest::glue_with_null("Uploaded documentation to '{doc_url}'"))

    if (upload_type == "temp") {
      repo_metadata <- github.tools::create_repo_metadata(
        owner = utils.nest::sys_env_non_empty("DRONE_REPO_NAMESPACE"),
        repo = utils.nest::sys_env_non_empty("DRONE_REPO_NAME"),
        github_api_server = utils.nest::sys_env_non_empty("GITHUB_API_SERVER"),
        github_token = utils.nest::sys_env_non_empty("GITHUB_REPO_TOKEN"),
        check_repo_exists = TRUE
      )
      pr_id <- as.integer(utils.nest::sys_env_non_empty("DRONE_PULL_REQUEST"))
      commit_sha <- utils.nest::sys_env_non_empty("DRONE_COMMIT_SHA")
      update_pr_temp_doc_description(doc_url, pr_id, commit_sha, repo_metadata = repo_metadata)
    }

    EOF

---

# run more extensive tests on the master and devel branch overnight, this is an extension of check_PR except that no documentation is generated
# execute "drone build promote repoName successfulBuildId environment", e.g. drone build promote mordigm/testRep1 21 testing
# e.g. configure as a cron job (also available directly with Drone Enterprise)
# This is currently very similar to testing check_PR.yaml, but clone strategy similar to push_master.yaml

kind: pipeline
name: extensive tests of the master and devel branch

trigger:
  branch:
  - master
  - devel
  event:
  - promote

clone:
  disable: true

image_pull_secrets:
- .dockerconfigjson

steps:
- name: Info about run
  image: alpine
  commands:
  - printenv

- name: clonerepo
  # we don't take the standard drone/git behavior because it only has five parameters and we need a more customized git setup
  image: plugins/git
  commands:
  # --depth 1 option only checkouts master, not useful here
  - git clone "${DRONE_GIT_HTTP_URL}" sourcecode
  - cd sourcecode
  - git branch -a
  - git checkout "$DRONE_COMMIT_SHA"
  - git status
  - '[ "$(git diff --name-only origin/master -- .drone.yml)" == "" ] || exit 1' # fail if yaml is different from master

- name: extensive check of code
  image: docker.bioclinr.com:10021/nest/allprojects:v1
  pull: always
  environment:
    EXTENSIVE_TESTING: true
  entrypoint:
  - bash
  commands:
  - echo "ExtTesting:" $EXTENSIVE_TESTING
  - |-
    R --vanilla <<- 'EOF'
    library(automation.utils)

    get_package_version("sourcecode")
    utils.nest::stop_if_not(list(check_pkg("sourcecode")$passed, "Check the package"))

    EOF

...

