% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rtabulate_refactor.R
\name{rtabulate}
\alias{rtabulate}
\title{Direct Tabulation}
\usage{
rtabulate(
  x,
  col_by = by_all("col_1"),
  FUN = rtab_inner,
  ...,
  row_by = NULL,
  format = NULL,
  row.name = "",
  indent = 0,
  col_wise_args = list(),
  total = NULL,
  col_N = NULL
)
}
\arguments{
\item{x}{either a vector or \code{data.frame}}

\item{col_by}{(\code{\link{factor}} or \code{\link{data.frame}}
if a \code{\link{factor}} of length \code{nrow(x)} that defines
which levels in \code{col_by} define a column.}

\item{FUN}{a function that processes the cell data}

\item{...}{arguments passed to the tabulation function}

\item{row_by}{rows in \code{x} to take per row in the resulting table}

\item{format}{if \code{FUN} does not return a formatted \code{\link{rcell}}
then the \code{format} is applied}

\item{row.name}{if \code{NULL} then the \code{FUN} argument is deparsed and
used as \code{row.name} of the \code{\link{rrow}}}

\item{indent}{deprecated.}

\item{col_wise_args}{a named list containing collections (e.g. vectors or
lists) with data elements for each column of the resulting table. The data
elements are then passed to the named argument \code{FUN} corresponding to
the element name of the outer list. Hence, the length and order of each
collection must match the levels in \code{col_by}. See examples.}

\item{total}{string of column name of an added total column using \code{\link[rtables]{by_add_total}} to
\code{col_by} and to \code{col_N}. If \code{NULL} no total column is added.}

\item{col_N}{numeric. If non-NULL, counts to override total column counts.}
}
\value{
an \code{\link{rtable}} object
}
\description{
\code{rtablulate} provides a direct tabulation API conceptually derived from \code{\link{tapply}}.
}
\details{
In practice, a Pre-data layout is built up based on the
arguments using hierarchical splitting for rows and columns as necessary, then analyzing all variables in \code{x} via \code{FUN} (which defaults to \code{\link{rtab_inner}}). This layout is then applied to the full data (the combination of \code{x}, \code{col_by} and, if non-null, \code{row_by}).
}
\note{
For backwards compatibility, all paramters other than \code{x}, \code{col_by} and \code{FUN} appear after \dots so must be specified by full argument name.
}
\examples{
## logical
rtabulate(iris$Species == "setosa", by_all("Species"),
  FUN = function(x, N) c(sum(x), sum(x)/N),
  row.name = "n (n/N)",
  col_wise_args = list(N = 150),
  format = "xx (xx.xx\%)")


# default FUN is number of observations equal to TRUE
with(iris, rtabulate(Sepal.Length < 5, Species, row.name = "Sepal.Length < 5"))

# Custom FUN: number of TRUE records in a cell and precentages based on number of records
# in each column
with(iris, rtabulate(Sepal.Length < 5, Species,
  FUN = function(xi, N) sum(xi) * c(1, 1/N),
  format = "xx.xx (xx.xx\%)",
  row.name = "Sepal.Length < 5",
  col_wise_args = list(N = table(Species))
))


## numerics
rtabulate(iris$Sepal.Length)

rtabulate(iris$Sepal.Length, col_by = by_all("Sepal.Length"))

with(iris,  rtabulate(x = Sepal.Length, col_by = Species, row.name = "mean"))

SL <- iris$Sepal.Length
Sp <- iris$Species
rbind(
  rtabulate(SL, Sp, length, row.name = "n"),
  rtabulate(SL, Sp, function(x)c(mean(x), sd(x)), format = "xx.xx (xx.xx)", row.name = "Mean (SD)"),
  rtabulate(SL, Sp, median, row.name = "Median"),
  rtabulate(SL, Sp, range, format = "xx.xx - xx.xx", row.name = "Min - Max")
)

# TODO: enable sprintf_format in rtabulate
 x <- 1:100
 cb <- factor(rep(LETTERS[1:3], c(20, 30, 50)))

 rtabulate(
   x = x, col_by = cb,
   FUN = function(x, N) c(mean(x), sd(x), N),
   format = sprintf_format("\%.2f (\%.2f) and \%i"),
   row.name = "Mean (SD) and N",
   col_wise_args = list(N = table(cb))
 )



## factors
rtabulate(x = iris$Species)

 rtabulate(x = iris$Species, useNA = "always")
 rtabulate(x = factor(c("a", "a", NA, "b")), useNA = "ifany")

rtabulate(x = iris$Species, by_all("sum"))

sl5 <- factor(iris$Sepal.Length > 5, levels = c(TRUE, FALSE),
   labels = c("S.L > 5", "S.L <= 5"))

rtabulate(iris$Species, col_by = sl5)
rtabulate(sl5, iris$Species)

rtabulate(iris$Species, col_by = sl5,
          FUN = function(dat, .N_total) {
    tb <- table(dat)
    lapply(tb, function(cell_count) {
     if (cell_count > 10) {
        cell_count * c(1, 1/.N_total)
     } else {
        rcell("-", format = "xx")
     }
     })
   },
   format = "xx (xx.xx\%)")

rtabulate(x = factor(c("X", "Y"), c("X", "Y")),
          col_by = factor(c("a", "a"), c("a", "b")), FUN = length)

rtabulate(factor(c("Y", "Y"), c("X", "Y")),
          factor(c("b", "b"), c("a", "b")), length)

rtabulate(
  x = factor(c("Y", "Y"), c("X", "Y")),
  col_by = factor(c("b", "b"), c("a", "b")),
  FUN = function(x, N) lapply(table(x), function(tbi) c(tbi, N)),
  col_wise_args = list(N = c(1,2))
)

## data.frames
df <- expand.grid(aaa = factor(c("A", "B")), bbb = factor(c("X", "Y", "Z")))
df <- rbind(df, df)
df$val <- 1:nrow(df)

 rtabulate(
   x = df,
   row_by = df$aaa,
   col_by = df$bbb,
   FUN = function(df) {
      sum(df$val)
   }
 )

 ## this is largely nonsensical, all is not really a "row by" here
 ## that's why we get the label row and data row
 rtabulate(
   x = iris,
   row_by = by_all("sum"),
   col_by = iris$Species,
   FUN = function(df) sum(df$Sepal.Length)
 )

## standard way would be this
rtabulate(
    x = iris,
    col_by = iris$Species,
    FUN = function(df) sum(df$Sepal.Length),
    row.name =  "sum")


 rtabulate(
   x = iris,
   row_by = iris$Species,
   col_by = by_all("sum"),
   FUN = function(df) sum(df$Sepal.Length)
 )

 fsl5 <- factor(iris$Sepal.Length > 5, levels = c(TRUE, FALSE),
     labels = c("S.L > 5", "S.L <= 5"))

 tbl <- rtabulate(
   x = iris,
   row_by = fsl5,
   col_by = iris$Species,
   FUN = function(df) {
     if (nrow(df) < 10) {
       rcell("-")
     } else {
       fit <- lm(Sepal.Length ~ Petal.Width, data = df)

       rcell(list(fit), format = function(x, output) {
           paste("df:", x[[1]]$df.residual)
       })
     }
   }
 )
 tbl

 rtabulate(
   x = iris,
   row_by = fsl5,
   col_by = iris$Species,
   FUN = function(df, N) {
      N
   },
   col_wise_args = list(N = c(10, 100, 200))
 )
#
#
#
}
\author{
Gabriel Becker and Adrian Waddell
}
