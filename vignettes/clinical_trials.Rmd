---
title: "Tables in Clinical Trials"
author: "Gabriel Becker and Adrian Waddell"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Tables in Clinical Trials}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r, echo=FALSE}
knitr::opts_chunk$set(comment = "")
```

## Introduction

In this vignette we show how `rtables` can be used to get simplified version of a demographic table, adverse event table and a response table. We don't aim to create fully specified and flexible tables here, we only want to demonstrate that layouts are very flexible and can be used to create tables used to analyze clinical trials data. At Roche we have another project called `tern` to create standard tables with full parameterization to meet the requirements of the analysts.

Note that all the data used here is created using random number generators with another internal R package called `random.cdisc.data`. We have attached some data to this package but we do intend to release `random.cdisc.data` as open source soon.


```{r, message=FALSE}
library(rtables)
library(dplyr)
```

## Demographic Table

Demographic tables are used to summarize variables and compare their values between columns. We will now create a simple demographic table. 

One feature of `analyze` that we have not introduced yet is that the analysis function `afun` can specify multiple rows:


```{r}
ADSL <- ex_adsl

basic_table() %>%
  split_cols_by("ARM") %>%
  analyze("AGE", afun = function(x) {
    in_rows(
      "Mean (sd)" = rcell(c(mean(x), sd(x)), format = "xx.xx (xx.xx)"),
      "Range" = rcell(range(x), format = "xx.xx - xx.xx")
    )
  }) %>%
  build_table(ADSL)
```

and further multiple variables can be analyzed in one `analyze` call

```{r}
basic_table() %>%
  split_cols_by("ARM") %>%
  analyze(c("AGE", "BMRKR1"), afun = function(x) {
    in_rows(
      "Mean (sd)" = rcell(c(mean(x), sd(x)), format = "xx.xx (xx.xx)"),
      "Range" = rcell(range(x), format = "xx.xx - xx.xx")
    )
  }) %>%
  build_table(ADSL)
```

Hence if our function passed to the `afun` argument can process different argument types then we are fairly close to a standard demographic table. Here is a function that creates count table for factors and some summary calculation for numerical variables:


```{r}
s_summary <- function(x, lblstr, ...) {
  if (is.numeric(x)) {
    in_rows(
      "n" = rcell(sum(!is.na(x)), format = "xx"),
      "Mean (sd)" = rcell(c(mean(x, na.rm = TRUE), sd(x, na.rm = TRUE)), format = "xx.xx (xx.xx)"),
      "IQR" = rcell(IQR(x, na.rm = TRUE), format = "xx.xx"),
      "min - max" = rcell(range(x, na.rm = TRUE), format = "xx.xx - xx.xx")
    )
  } else if (is.factor(x)) {
    
    vs <- as.list(table(x))
    do.call(in_rows, lapply(vs, rcell, format = "xx"))
    
  } else (
    stop("type not supported")
  )
}
```


note we use `rcell`s to wrap the results. We can use `s_summary` outside the context of tabulation:

```{r}
s_summary(iris$Sepal.Length)
```

and 

```{r}
s_summary(iris$Species)
```

Hence, we can now create a demographic table:

```{r}
lyt <- basic_table() %>% 
  split_cols_by(var = "ARM", lbl = "ARM") %>%
  analyze(var = c("AGE", "SEX"), afun = s_summary) 

tbl <- build_table(lyt, ADSL)
tbl
```

Note that `analyze` can also be called multiple times in sequence:

```{r}
tbl2 <- basic_table() %>% 
  split_cols_by(var = "ARM", lbl = "ARM") %>%
  analyze(var = "AGE", afun = s_summary) %>%
  analyze(var = "SEX", afun = s_summary) %>%
  build_table(ADSL) 

tbl2
```

which leads to the identical table as `tbl1`:

```{r}
identical(tbl, tbl2)
```

Column `N`s (population size represented by column) are added using the `add_colcounts` function:

```{r}
basic_table() %>% 
  split_cols_by(var = "ARMCD", vlblvar = "ARM") %>%
  add_colcounts() %>%
  analyze(var = c("AGE", "SEX"), afun = s_summary) %>%
  build_table(ADSL) 
```

### Variations on the demographic table


```{r}
basic_table() %>% 
  split_cols_by(var = "ARM", lbl = "ARM") %>%
  split_rows_by("SEX") %>%
  summarize_row_groups() %>%
  analyze(var = c("AGE", "BEP01FL"), afun = s_summary) %>%
  build_table(ADSL) 
```

```{r}
basic_table() %>% 
  split_cols_by(var = "ARM", lbl = "ARM") %>%
  split_rows_by("SEX") %>%
  summarize_row_groups(cfun = function(xi, lblstr) sum(!is.na(xi)), fmt = "xx") %>% 
  analyze(var = c("AGE", "BEP01FL"), afun = s_summary) %>%
  build_table(ADSL) 
```

```{r}
# basic_table %>% 
#   split_cols_by(var = "ARM", lbl = "ARM") %>%
#   split_rows_by("SEX") %>%
#   summarize_row_groups(cfun = function(xi, lblstr) {
#     rcell(sum(!is.na(xi)), lbl = paste(lblstr, "(n)"))
#   }, fmt = "xx", lbl_fstr = "%s (n)") %>%
#   analyze(var = c("AGE", "BEP01FL"), afun = s_summary) %>%
#   build_table(ADSL) 
```


```{r}
# basic_table() %>% 
#   split_cols_by(var = "ARM", lbl = "ARM") %>%
#   split_rows_by("RACE") %>%
#   summarize_row_groups_count(lbl_fstr = "%s (n)") %>%
#   analyze(var = c("AGE", "SEX"), afun = s_summary) %>%
#   build_table(ADSL) 
```

### Using Layouts

Note that the layouts can be used for different subsets of the `ADSL` dataset:

```{r}
lyt <- NULL %>% 
  split_cols_by(var = "ARM", lbl = "ARM") %>%
  analyze(var = c("AGE", "SEX"), afun = s_summary)

build_table(lyt, ADSL)

build_table(lyt, ADSL %>% filter(AGE > 18))
```


## Adverse Events

## Response Table


```{r, eval=FALSE}
iter_colby = function(lyt, cbys, baselines = vector("list", length(cbys))) {

    ##unpiped version
    for(i in seq_along(cbys)) {
        cb = cbys[[i]]
        if(!is.null(baselines[[i]]))
            lyt = split_cols_by(lyt, cb, lbl = cb, baseline = baselines[[i]])
        else
            lyt = split_cols_by(lyt, cb, lbl = cb)
    }
    lyt
}

TF_counter = function(nms = NULL) {
    function(x, .N_col) {
    tcnt = sum(x)
    fcnt = .N_col - tcnt
    ret = list(c(tcnt, tcnt/.N_col),
               c(fcnt, fcnt/.N_col))
    if(!is.null(nms))
        names(ret) = nms
    ret

    }
}


.make_2xk_tab = function(coldat, bldat) {
    if(is.list(coldat) && length(coldat) == 1)
        coldat = coldat[[1]]
    if(is.list(bldat) && length(bldat) == 1)
        bldat = bldat[[1]]
    
    catvec = c(rep("baseline", times = length(bldat)),
               rep("coldata", times = length(coldat)))
    tab = table(catvec, c(bldat, coldat))
    tab
}

## TODO: remove internal package-code use of %>% (maybe?)

tt_rsp_lyt = function(col_by, baselines = vector("list", length(col_by))) {
    NULL %>% iter_colby(cbys = col_by, baselines = baselines) %>%
        ## respodner and nonresponder counts
        add_analyzed_var("rsp", lbl = " ",
                         afun = TF_counter( nms = c("Responders", "Non-Responders")),
                         fmt = "xx (xx.%)") %>%
        
        ## response rate CI
        add_analyzed_var("rsp", lbl = " ",
                         afun = function(x) {
            list("95% CI for Response Rates (Clopper-Pearson)" = binom.test(sum(x), length(x))$conf.int * 100)
        }, fmt = "(xx.xx, xx.xx)", newtoplev = TRUE) %>%
        
        ## Difference in Response Rates section
        ## I think this one should acttually e a content row?
        analyze_against_baseline(var = "rsp", lbl =" ",
                               afun = function(x) c("Difference in Response Rates (%)" =  mean(x)*100), fmt = "xx.xx", newtoplev = TRUE) %>%
        
        ## (both) CIs for diff in response rates
        analyze_against_baseline_2dtable(var = "rsp", lbl = " ",
                              compfun = function(tab) {
            list("95% CI for difference (Wald without continuity correction)"=
                     prop.test(tab, correct = FALSE)$conf.int*100,
                 "95% CI for difference (Wald with continuity correction)" =
                     prop.test(tab, correct = TRUE)$conf.int*100)
        }, fmt = "(xx.xx, xx.xx)", newtoplev = TRUE) %>%
        
        ## Odds ratio
        analyze_against_baseline_2dtable(var = "rsp",
                              lbl = " ",
                              compfun = function(tab) {
            fit = tern:::odds_ratio(tab)
            list("Odds Ratio" = fit$estimator,
                 "95% CI" = fit$conf.int)
            }, fmt = c("xx.xx", "(xx.xx, xx.xx)"), newtoplev = TRUE) %>%
        ## Response rates by type of response
        split_rows_by("AVALC", " ",
                            splfun = reord_levs_sfun(neworder = c("CR", "PR", "SD", "NON CR/PD", "PD", "NE"), drlevels = TRUE), newtoplev = TRUE) %>%
        ## counts are a summary content row
        summarize_row_groups("AVALC", "%s") %>%
        ## CIs are an analysis row
        add_analyzed_var("AVALC", lbl = " ", afun = function(x, .N_col) {
            list("95% CI" = binom.test(length(x), .N_col)$conf.int * 100)
        }, fmt = "(xx.xx, xx.xx)")

}

```