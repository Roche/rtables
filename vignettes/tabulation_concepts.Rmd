---
title: "Tabulation Concepts"
author: "Adrian Waddell"
date: "6/12/2020"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Tabulation Concepts}
  \usepackage[utf8]{inputenc}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction

There are a number of ways tabulating data

* layout based tabulation as defined in `rtables`
* use the `rtabulate` framework
* use use other means like `dplyr` to derive the numbers for a table (see the `tabulation_dplyr` vignette)


For this vignette we will use the following packages:

```{r}
library(dplyr)
library(tibble)
library(rtables)
```

... and following data:

```{r}
add_subgroup <- function(x) {
  paste0(tolower(x), sample(1:3, length(x), TRUE))
}
set.seed(1)
df <- tibble(
  x = rnorm(100),
  c1 = factor(sample(c("A", "B", "C"), 100, replace = TRUE), levels = c("A", "B", "C")),
  r1 = factor(sample(c("U", "V", "W"), 100, replace = TRUE), levels = c("U", "V", "W"))
) %>%
  mutate(
    c2 = add_subgroup(c1),
    r2 = add_subgroup(r1),
    y = as.numeric(2*as.numeric(c1) - 3 * as.numeric(r1))
  ) %>% select(c1, c2, r1, r2, x, y)

df
```

## Tabulation Patterns I

Let's say we would like to create the following table:

```
            A         B         C
--------------------------------------
U        foo(df_UA)  foo(df_UB)  foo(df_UC)
V        foo(df_VA)  foo(df_VB)  foo(df_VC)
W        foo(df_WA)  foo(df_WB)  foo(df_WC)
```

where `df_*` are subsets of `df` as follows:

```{r}
df_UA <- df %>% filter(r1 == "U", c1 == "A")
df_VA <- df %>% filter(r1 == "V", c1 == "A")
df_WA <- df %>% filter(r1 == "W", c1 == "A")
df_UB <- df %>% filter(r1 == "U", c1 == "B")
df_VB <- df %>% filter(r1 == "V", c1 == "B")
df_WB <- df %>% filter(r1 == "W", c1 == "C")
df_UC <- df %>% filter(r1 == "U", c1 == "C")
df_VC <- df %>% filter(r1 == "V", c1 == "C")
df_WC <- df %>% filter(r1 == "W", c1 == "C")
```

further note that `df_*` are of the same class as `df`, i.e. `tibble`s. Hence `foo` aggregates the subset of our data to a cell value.

Given a function `foo` (ignore the `...` for now):

```{r}
foo <- function(df, ...) {
  paste(dim(df), collapse = " x ")
}
```

we can start calculating the cell values individually:

```{r}
foo(df_UA)
foo(df_VA)
foo(df_WA)
foo(df_UB)
foo(df_VB)
foo(df_WB)
foo(df_UC)
foo(df_VC)
foo(df_WC)
```

Now we are still missing the table structure:

```{r}
matrix(
  list(
    foo(df_UA),
    foo(df_VA),
    foo(df_WA),
    foo(df_UB),
    foo(df_VB),
    foo(df_WB),
    foo(df_UC),
    foo(df_VC),
    foo(df_WC)
  ), 
  byrow = FALSE, ncol = 3
)
```

In `rtables` this type of tabulation is done with `layouts`

```{r}
basic_table() %>%
  split_cols_by("c1") %>%
  split_rows_by("r1") %>%
  analyze("x", foo) %>%
  build_table(df)
```

or if we would not want to see the `foo` label we would have to use 

```{r}
basic_table() %>%
  split_cols_by("c1") %>%
  split_rows_by("r1") %>%
  summarize_row_groups(cfun = foo, format = "xx") %>%
  build_table(df)
```

but now the row labels diapered. This is because `cfun` needs to define it's row label. So let's redefine `foo`:


```{r}
foo <- function(df, labelstr) {
  rcell(paste(dim(df), collapse = " x "), format = "xx", label = labelstr)
}

basic_table() %>%
  split_cols_by("c1") %>%
  split_rows_by("r1") %>%
  summarize_row_groups(cfun = foo) %>%
  build_table(df)
```


### Calculating the Mean

For lets calculate the mean of `df$y` for pattern I. 

```{r}
foo <- function(df, labelstr) {
  rcell(mean(df$y), label = labelstr, format = "xx.xx")
}

basic_table() %>%
  split_cols_by("c1") %>%
  split_rows_by("r1") %>%
  summarize_row_groups(cfun = foo) %>%
  build_table(df)
```

Note that `foo` has the variable information hard encoded in the function body. Let's try some alternatives returning to `analyze`:


```{r}
basic_table() %>%
  split_cols_by("c1") %>%
  split_rows_by("r1") %>%
  analyze("y", afun = mean) %>%
  build_table(df)
```

note that the subset of the `y` variable is passed as `x` argument to `mean` **TODO: or first argument?**. We could also get the tibble instead of the variable:

```{r}
basic_table() %>%
  split_cols_by("c1") %>%
  split_rows_by("r1") %>%
  analyze("y", afun = function(df) mean(df$y)) %>%
  build_table(df)
```

which is in contrast to:

```{r}
basic_table() %>%
  split_cols_by("c1") %>%
  split_rows_by("r1") %>%
  analyze("y", afun = function(x) mean(x)) %>%
  build_table(df)
```

where the function receives the subset of `y`.

### Group Summaries

Pattern I is an interesting one as we can add more row structure (with further splits). Consider the following table:

```
            A         B         C
--------------------------------------
U        
  u1     foo(<>)  foo(<>)  foo(<>)
  u2     foo(<>)  foo(<>)  foo(<>)
  u3     foo(<>)  foo(<>)  foo(<>)
V 
  v1     foo(<>)  foo(<>)  foo(<>)
  v2     foo(<>)  foo(<>)  foo(<>)
  v3     foo(<>)  foo(<>)  foo(<>)
W
  w1     foo(<>)  foo(<>)  foo(<>)
  w2     foo(<>)  foo(<>)  foo(<>)
  w3     foo(<>)  foo(<>)  foo(<>)
```

where `<>` represents the data that is represented by the cell. So for the cell `U > u1, A` we would have the subset:

```{r}
df %>% 
  filter(r1 == "U", r2 == "u1", c1 == "A")
```

and so on. We can get this table as follows:


```{r}
basic_table() %>%
  split_cols_by("c1") %>%
  split_rows_by("r1") %>%
  split_rows_by("r2") %>%
  summarize_row_groups(cfun = function(df, labelstr) {
    rcell(foo(df$x), format = "xx.xx", label = labelstr)
  }) %>% 
  build_table(df)
```

or, if we wanted to calculate two summaries per row split:

```{r}
s_mean_sd <- function(x) {
  in_rows("mean (sd)" = rcell(c(mean(x), sd(x)), format = "xx.xx (xx.xx)"))
}

s_range <- function(x) {
  in_rows("range" = rcell(range(x), format = "xx.xx - xx.xx"))
}

basic_table() %>%
  split_cols_by("c1") %>%
  split_rows_by("r1") %>%
  split_rows_by("r2") %>%
  analyze("x", s_mean_sd, show_labels = "FALSE") %>%
  analyze("x", s_range, show_labels = "FALSE") %>%
  build_table(df)
```

**TODO: remove x label, what happened to the formats?**.

Which has the following structure:

```
                          A         B         C
--------------------------------------
U        
  u1
     mean_sd  s_mean_sd(<>)  s_mean_sd(<>)  s_mean_sd(<>)
     range    s_range(<>)    s_range(<>)    s_range(<>)
  u2
     mean_sd  s_mean_sd(<>)  s_mean_sd(<>)  s_mean_sd(<>)
     range    s_range(<>)    s_range(<>)    s_range(<>)
  u3
     mean_sd  s_mean_sd(<>)  s_mean_sd(<>)  s_mean_sd(<>)
     range    s_range(<>)    s_range(<>)    s_range(<>)
V 
  v1
     mean_sd  s_mean_sd(<>)  s_mean_sd(<>)  s_mean_sd(<>)
     range    s_range(<>)    s_range(<>)    s_range(<>)
  v2
     mean_sd  s_mean_sd(<>)  s_mean_sd(<>)  s_mean_sd(<>)
     range    s_range(<>)    s_range(<>)    s_range(<>)
  v3
     mean_sd  s_mean_sd(<>)  s_mean_sd(<>)  s_mean_sd(<>)
     range    s_range(<>)    s_range(<>)    s_range(<>)
W
  w1
     mean_sd  s_mean_sd(<>)  s_mean_sd(<>)  s_mean_sd(<>)
     range    s_range(<>)    s_range(<>)    s_range(<>)
  w2
     mean_sd  s_mean_sd(<>)  s_mean_sd(<>)  s_mean_sd(<>)
     range    s_range(<>)    s_range(<>)    s_range(<>)
  w3
     mean_sd  s_mean_sd(<>)  s_mean_sd(<>)  s_mean_sd(<>)
     range    s_range(<>)    s_range(<>)    s_range(<>)
```

## Pattern II

Let's look at another pattern:

```
                     A         B         C
------------------------------------------------
foo_label        foo(df_A)  foo(df_B)  foo(df_C)
bar_label        bar(df_A)  bar(df_B)  bar(df_C)
zoo_label        zoo(df_A)  zoo(df_B)  zoo(df_C)
```

note that now the rows represent different analyses for the subset defined by the respective column and:

```{r}
df_A <- df %>% filter(c1 == "A")
df_B <- df %>% filter(c1 == "B")
df_C <- df %>% filter(c1 == "C")
```


Let's do this first with `analyze`:

```{r}
foo <- prod
bar <- sum
zoo <- mean

basic_table() %>%
  split_cols_by("c1") %>%
  analyze("x", function(df) foo(df$x), var_labels = "foo label", format = "xx.xx") %>%
  analyze("x", function(df) bar(df$x), var_labels = "bar label", format = "xx.xx") %>%
  analyze("x", function(df) zoo(df$x), var_labels = "zoo label", format = "xx.xx") %>%
  build_table(df)
```

**TODO: why are the labels showing up twice?**

of if we wanted

```
                     A         B         C
------------------------------------------------
foo_label        foo(x_A)  foo(x_B)  foo(x_C)
bar_label        bar(x_A)  bar(x_B)  bar(x_C)
zoo_label        zoo(x_A)  zoo(x_B)  zoo(x_C)
```

where

```{r}
x_A <- df$x[df$c1 == "A"]
x_B <- df$x[df$c1 == "B"]
x_C <- df$x[df$c1 == "C"]
```

we can do this less verbose as the `afun` gets the subset of the specified variable if `afun` has an argument `x`:

```{r}
basic_table() %>%
  split_cols_by("c1") %>%
  analyze("x", foo, var_labels = "foo label", format = "xx.xx") %>%
  analyze("x", bar, var_labels = "bar label", format = "xx.xx") %>%
  analyze("x", zoo, var_labels = "zoo label", format = "xx.xx") %>%
  build_table(df)
```



### Pattern III

Let's consider the following tabulation pattern:

```
                     A         B         C
------------------------------------------------
label 1        foo(x_A)  bar(x_B)  zoo(x_C)
label 2        foo(x_A)  bar(x_B)  zoo(x_C)
label 3        foo(x_A)  bar(x_B)  zoo(x_C)
```

**TODO: currently this is not possible**
